# Лабораторная работа №4
> Для лаб по оптимизации - Лабораторная №3

> Лабораторная работа выполнена на Ubuntu Linux 24.04
## Техническое задание
* Поднять kubernetes кластер локально (например minikube)
* В нём развернуть свой сервис, используя 2-3 ресурса kubernetes.
* В идеале разворачивать кодом из yaml файлов одной командой запуска.
* Показать работоспособность сервиса.
* Прочитать книжку про жирафа
## Теор обзор
**Kubernetes** (часто сокращается до K8s) — это мощная платформа с открытым исходным кодом для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями. С помощью него можно управлять контейнерами, развёртывать и масштибировать приложения, он не даёт им простаивать и обновляет приложения, так же кубер автоматически перекидывает на другие узлы приложения при неисправности контейнера или узла.

**Minikube** — это инструмент для запуска локального Kubernetes-кластера на вашем компьютере.
**kubectl** — это CLI (интерфейс командной строки) для управления Kubernetes-кластером (включая кластер, созданный Minikube)

Вместе они делают следующие вещи: 

* Minikube создает локальный Kubernetes-кластер.
* kubectl используется для управления этим кластером:
1. Развертывание приложений.
2. Проверка состояния кластера.
3. Управление ресурсами.
## Установка Minikube и kubectl
* Сначала я обновил всё что было необходимо командой:
```
sudo apt-get update
```
* После я установил миникуб, взяв инфу с этого [сайта](https://minikube.sigs.k8s.io/docs/start/).
* Инфу для установки kubectl я брал [отсюда](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
* После того, как у вас всё скачалось - вводим команду:
```
minikube start
```
![изображение](https://github.com/user-attachments/assets/5762d6d0-c3e0-4e22-b9c7-589f9bcbf075)

Сначала у меня высветлся такой прикол, по факту - это не критично, я запускал и с этим предупреждением контейнеры и приложения спокойно отображались в браузере, на всякий случай - можно очистить и снова запустить миникуб, у меня оказались проблемы с DNS, поэтому я так и сделал, тем более ничего важного я пока не делал с помощью миникуба. В итоге, идеальный вариант должен выглядеть так: 

![изображение](https://github.com/user-attachments/assets/fc1aafc6-0dc1-436c-89ed-9495823180bf)

## Создание Docker-образа для сервера

* Создаём директорию, снизу - пример:
```
mkdir my-flask-app
cd my-flask-app
```
* Далее создаём код приложения, которое будет у вас отображаться в браузере, в моём случае - это простое приложение на питоне: `app.py`, которое будет здороваться, показывать время и кидать приколюху из символов, внизу кода - строчки, которые запускают веб сервер Flask, так же код настроен на то, чтобы он был доступен на всех сетевых интерфейсах и слушался порт 5000
```
from flask import Flask
from datetime import datetime

app = Flask(__name__)

@app.route('/')
def hello():
    now = datetime.now()
    art = """
<pre>
-------------------------------------------------------------------------------------------------------------------------------
______█████████
______█▄█████▄█
______█▼▼▼▼▼█        
_____██▌_______██   NIAM NIAM
______█▲▲▲▲▲█
______█████████
______ ██_____██ 
-------------------------------------------------------------------------------------------------------
</pre>
"""
    return f"Hello, World! Current time is {now.strftime('%Y-%m-%d %H:%M:%S')}, you may see a funny page: {art}"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

* Создаём файл Dockerfile:
```
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "app.py"]
```
* Создаём файл requirements.txt:
```
Flask==2.0.1
Werkzeug==2.0.3
```
* Flask==2.0.1: Веб-фреймворк для создания приложений.
* Werkzeug==2.0.3: Низкоуровневая библиотека, которую Flask использует для обработки запросов и других задач.


