# Лабораторная работа №4
> Для лаб по оптимизации - Лабораторная №3

> Лабораторная работа выполнена на Ubuntu Linux 24.04
## Техническое задание
* Поднять kubernetes кластер локально (например minikube)
* В нём развернуть свой сервис, используя 2-3 ресурса kubernetes.
* В идеале разворачивать кодом из yaml файлов одной командой запуска.
* Показать работоспособность сервиса.
* Прочитать книжку про жирафа
## Теор обзор
**Kubernetes** (часто сокращается до K8s) — это мощная платформа с открытым исходным кодом для автоматизации развертывания, масштабирования и управления контейнеризированными приложениями. С помощью него можно управлять контейнерами, развёртывать и масштибировать приложения, он не даёт им простаивать и обновляет приложения, так же кубер автоматически перекидывает на другие узлы приложения при неисправности контейнера или узла.

**Minikube** — это инструмент для запуска локального Kubernetes-кластера.
**kubectl** — это CLI (интерфейс командной строки) для управления Kubernetes-кластером (включая кластер, созданный Minikube)

Вместе они делают следующие вещи: 

* Minikube создает локальный Kubernetes-кластер.
* kubectl используется для управления этим кластером:
1. Развертывание приложений.
2. Проверка состояния кластера.
3. Управление ресурсами.
## Установка Minikube и kubectl
* Сначала я обновил всё что было необходимо командой:
```
sudo apt-get update
```
* После я установил миникуб, взяв инфу с этого [сайта](https://minikube.sigs.k8s.io/docs/start/).
* Инфу для установки kubectl я брал [отсюда](https://kubernetes.io/docs/tasks/tools/install-kubectl/).
* После того, как у вас всё скачалось - вводим команду:
```
minikube start
```
![изображение](https://github.com/user-attachments/assets/5762d6d0-c3e0-4e22-b9c7-589f9bcbf075)

Сначала у меня высветлся такой прикол, по факту - это не критично, я запускал и с этим предупреждением контейнеры и приложения спокойно отображались в браузере, на всякий случай - можно очистить и снова запустить миникуб, у меня оказались проблемы с DNS, поэтому я так и сделал, тем более ничего важного я пока не делал с помощью миникуба. В итоге, идеальный вариант должен выглядеть так: 

![изображение](https://github.com/user-attachments/assets/fc1aafc6-0dc1-436c-89ed-9495823180bf)

## Создание Docker-образа для сервера

* Создаём директорию, снизу - пример:
```
mkdir my-flask-app
cd my-flask-app
```
* Далее создаём код приложения, которое будет у вас отображаться в браузере, в моём случае - это простое приложение на питоне: `app.py`, которое будет здороваться, показывать время и кидать приколюху из символов, внизу кода - строчки, которые запускают веб сервер Flask, так же код настроен на то, чтобы он был доступен на всех сетевых интерфейсах и слушался порт 5000
```python
from flask import Flask
from datetime import datetime

app = Flask(__name__)

@app.route('/')
def hello():
    now = datetime.now()
    art = """
<pre>
-------------------------------------------------------------------------------------------------------------------------------
______█████████
______█▄█████▄█
______█▼▼▼▼▼█        
_____██▌_______██   NIAM NIAM
______█▲▲▲▲▲█
______█████████
______ ██_____██ 
-------------------------------------------------------------------------------------------------------
</pre>
"""
    return f"Hello, World! Current time is {now.strftime('%Y-%m-%d %H:%M:%S')}, you may see a funny page: {art}"

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

* Создаём файл Dockerfile:
```
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "app.py"]
```
* Создаём файл requirements.txt:
```
Flask==2.0.1
Werkzeug==2.0.3
```
1. Flask==2.0.1: Веб-фреймворк для создания приложений.
2. Werkzeug==2.0.3: Низкоуровневая библиотека, которую Flask использует для обработки запросов и других задач.

* Собираем образ докера
```
docker build -t my-flask-app:1.0 .
```
* Далее загружаем этот образ в миникубе
```
minikube image load my-flask-app:1.0
```
## Содаём кубернет-ресурсы: 
### Создаём файл deployment.yaml, для удобства - добавлены комменты к скрипту:
```yaml
# Версия API Kubernetes, которую вы используете.
# В данном случае это "apps/v1", что указывает на использование API для работы с Deployment.
apiVersion: apps/v1

# Тип ресурса Kubernetes, который вы создаете.
# В данном случае это "Deployment", который управляет развертыванием и обновлением подов (Pods).
kind: Deployment

# Метаданные Deployment.
metadata:
  # Имя Deployment. Это имя будет использоваться для идентификации Deployment в Kubernetes.
  name: my-flask-app

# Спецификация (описание) Deployment.
spec:
  # Количество реплик (копий) подов, которые должны быть запущены.
  # В данном случае Kubernetes будет поддерживать 2 копии вашего приложения.
  replicas: 2

  # Селектор, который определяет, какие поды управляются этим Deployment.
  # Kubernetes будет искать поды с метками, соответствующими указанным здесь.
  selector:
    matchLabels:
      # Метка, которая должна быть у подов, чтобы они управлялись этим Deployment.
      app: my-flask-app

  # Шаблон (template) для создания подов.
  template:
    # Метаданные для подов, создаваемых этим Deployment.
    metadata:
      # Метки, которые будут присвоены каждому поду.
      labels:
        app: my-flask-app

    # Спецификация (описание) подов.
    spec:
      # Список контейнеров, которые будут запущены в подах.
      containers:
        # Имя контейнера. Это имя используется для идентификации контейнера внутри пода.
        - name: my-flask-app
          # Образ Docker, который будет использоваться для создания контейнера.
          # В данном случае это образ "my-flask-app:1.0".
          image: my-flask-app:1.0
          # Порт, который будет открыт в контейнере.
          ports:
            # Номер порта, который контейнер будет слушать.
            - containerPort: 5000
```
### Создаём файл service.yaml:

В код я добавил комменты для лучшего понимания ситуации

```yaml
# Версия API Kubernetes, используемая для создания этого ресурса.
# "v1" — это версия API для работы с Service.
apiVersion: v1

# Тип ресурса Kubernetes, который вы создаете.
# В данном случае это "Service", который предоставляет доступ к приложениям, работающим в кластере.
kind: Service

# Метаданные Service.
metadata:
  # Имя Service. Это имя будет использоваться для идентификации Service в Kubernetes.
  name: my-flask-app

# Спецификация (описание) Service.
spec:
  # Селектор, который определяет, какие поды (Pods) будут связаны с этим Service.
  # Kubernetes будет искать поды с метками, соответствующими указанным здесь.
  selector:
    # Метка, которая должна быть у подов, чтобы они управлялись этим Service.
    app: my-flask-app

  # Портовая конфигурация Service.
  ports:
    # Определяет протокол и порты для Service.
    - protocol: TCP  # Протокол, который будет использоваться (TCP или UDP).
      port: 80       # Порт, который будет открыт на Service (внешний порт).
      targetPort: 5000  # Порт, который контейнеры слушают внутри подов (внутренний порт).

  # Тип Service. Определяет, как Service будет доступен извне.
  type: LoadBalancer
  # LoadBalancer — это тип Service, который создает внешний балансировщик нагрузки (если кластер поддерживает эту функцию).
  # В Minikube это обычно создает внешний IP-адрес, через который можно получить доступ к приложению.
```
## Развернём сервис в кубере 
### Применим конфиг, который мы написали в двух файлах выше:
```
kubectl apply -f deployment.yaml
kubectl apply -f service.yaml
```
### Поверим статус подов
```
kubectl get pods
```
### Получим URL сервиса
```
minikube service my-flask-app --url
```
### Проверка

Если у вас не было косяков, то в терминале всё будет выглядеть подобным образом: 

![изображение](https://github.com/user-attachments/assets/ea69290a-10c7-44d8-80e2-0bfd689a69f1)

Далее вобъём URL в браузер и в моём случае я увидел то, что ожидал: 

![изображение](https://github.com/user-attachments/assets/0e4eee0c-822f-48f6-9695-8913dfac1b2c)

## Очистка

Миникуб испольует контейнеры из докера, которые расходуют ресурсы пк, если их не остановить, то вся эта радость будет работать в фоновом режиме, поэтому обезопасим себя и удалим созданные ресурсы и остановим миникуб.

```
kubectl delete -f deployment.yaml
kubectl delete -f service.yaml
minikube stop
```

## Насчтёт книжки

Получил кайф и понимание от прочтения книги, теперь знаю, чтобы миникуб очень полезная штука для управления приложениями

## Подведение итогов

БЫл успешно развернут Kubernetes кластер локально с помощью Minikube и развернуто в нем простое веб-приложение на Flask. Сервис возвращает приветствие, время. Все действия были выполнены с использованием YAML-файлов, что позволяет легко воспроизвести развертывание одной командой.

[список лаб](https://github.com/VladislaZyuzin/ITMO_Cloud_Tech_Labas/tree/main)
