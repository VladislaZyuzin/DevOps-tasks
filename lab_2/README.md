# Лабораторная работа №2 (Выполнил Зюзин Владислав)
## Задания: 

1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов;
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены;
3. В Readme описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат;
4. В Readme описать 2 плохих практики по работе с контейнерами. ! Не по написанию докерфайлов, а о том, как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами.

## Установка Docker
> Перед началом уточню, что работа произведена на ОС **Ubuntu 24.04 LTS**.

Лучший гайд по установке докера я увидел вот тут: https://yandex.ru/video/preview/3719090281561281090

Так вышло, что я раньше выполнил лабу 2*, поэтому проверку работоспособности можно проверить там же, готов заверить, что благодаря гайду у меня установился докер без проблем!

## Плохой Dockerfile

Для его написания рассмотрим струкуру моего первого проекта по этой лабе: 
```
bad-docker/
├── Dockerfile
├── main.py
└── requirements.txt
```
### Мои файлы
* `main.py` - простое приложение на питоне с декоративными приколюхами:
```
print("Hello from the bad Docker container! ( ͡☉ ͜ʖ ͡☉)")
art = """
-------------------------------------------------------------------------------------------------------------------------------
______█████████
______█▄█████▄█
______█▼▼▼▼▼█        
_____██▌_______██   NIAM NIAM
______█▲▲▲▲▲█
______█████████
______ ██_____██ 
-------------------------------------------------------------------------------------------------------
"""

print(art)
```
* `requirements.txt` (пустой файл, так как приложение не использует внешние зависимости):
```
# Пустой файл
```
* Dockerfile
```
FROM ubuntu:latest

RUN apt-get update && apt-get install -y \
    python3 \
    python3-pip \
    && rm -rf /var/lib/apt/lists/*

COPY . /app

RUN pip3 install -r /app/requirements.txt

CMD ["python3", "/app/main.py"]
```
### Запуск

* Переходим в директорию `bad-docker`, если вы вернулись на начало
```
cd bad-docker
```
* Соберите образ:
```
docker build -t bad-docker .
```
![1](https://github.com/user-attachments/assets/b8a31f2c-8bbc-4f1e-96ae-92228926b62f)

* Запустите контейнер:
```
docker run bad-docker
```
Вывод:

![Снимок экрана от 2025-02-26 20-28-25](https://github.com/user-attachments/assets/6ed92673-6a53-4dad-839b-d6c104919593)

## Хороший докерфайл 

### Структура проекта:
```
good-docker/
├── Dockerfile
├── main.py
└── requirements.txt
```
### Файлы:
* `main.py` (простое Python-приложение):
```
from time import sleep 

print("Wana hear some song from good docker?")
sleep(2)  # Используем скобки для вызова функции sleep
print("Of course YES")
sleep(5)

art = """
....................„-~~'''''''~~--„„_
..............„-~''-,::::::::::::::::::: ''-„
..........,~''::::::::',:::::::::::::::: ::::|',
.... .::::::,-~'''¯¯¯''''~~--~'''¯'''-,:|
.........'|:::::|: : : : : : : : : : : ::: : |,'
........|:::::|: : :-~~---: : : -----: |
.......(¯''~-': : : :'¯°: ',: :|: :°-: :|
.....'....''~-,|: : : : : : ~---': : : :,'
...............|,: : : : : :-~~--: : ::/ NEVER GONNA GIVE YOU UP
......,-''\':\: :'~„„_: : : : : _,-' NEVER GONNA LET YOU DOOOWN
__„-';;;;;\:''-,: : : :'~---~''/| NEVER GONNA RUN AROUND AND DESERT YOU
;;;;;/;;;;;;;\: :\: : :____/: :',__
;;;;;;;;;;;;;;',. .''-,:|:::::::|. . |;;;;''-„__
;;;;;;,;;;;;;;;;\. . .''|::::::::|. .,';;;;;;;;;;''-„
;;;;;;;|;;;;;;;;;;;\. . .\:::::,'. ./|;;;;;;;;;;;;;|
;;;;;;;\;;;;;;;;;;;',: : :|¯¯|. . .|;;;;;;;;;,';;|
;;;;;;;;;',;;;;;;;;;;;\. . |:::|. . .'',;;;;;;;;|;;/
;;;;;;;;;;\;;;;;;;;;;;\. .|:::|. . . |;;;;;;;;|/
;;;;;;;;;;;;,;;;;;;;;;;|. .\:/. . . .|;;;;;;;;|
-------------------------------------------------------------------------------------------------------
"""
print(art)  
```
* `requirements.txt` (пустой файл, так как приложение не использует внешние зависимости):
```
# Пустой файл
```
* `Dockerfile` (хороший Dockerfile):
```
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt

COPY . /app

RUN useradd -m myuser && chown -R myuser:myuser /app
USER myuser

CMD ["python3", "main.py"]
```
### Запуск
* Перейдите в директорию good-docker:
```
cd good-docker
```
* Соберите образ:
```
docker build -t good-docker .
```
![Снимок экрана от 2025-02-26 21-01-11](https://github.com/user-attachments/assets/14e93df2-80ea-40e1-9e19-62b4bd173b43)

Запустите контейнер:
```
docker run good-docker
```
Получайте приколюху

![Снимок экрана от 2025-02-26 21-02-14](https://github.com/user-attachments/assets/dfd41c67-1f40-4fcd-8019-a9b32dc9e606)

## Описание плохих практик и их исправлений
### Плохая практика 1: Использование образа `latest`
* Почему это плохо?

Тег latest может измениться в любой момент, что приведет к непредсказуемым изменениям в вашем контейнере.

Это может вызвать проблемы с совместимостью или безопасностью.

* Как исправлено?

Используется конкретная версия образа: `python:3.9-slim.`

Это обеспечивает стабильность и предсказуемость.

### Плохая практика 2: Установка всех зависимостей в один слой
* Почему это плохо?

Каждый слой в Docker кэшируется. Если вы измените код, но не зависимости, Docker пересоберет все слои, включая установку зависимостей.

Это увеличивает время сборки и размер образа.

* Как исправлено?

Зависимости устанавливаются отдельно от копирования кода:
```
Dockerfile
Copy
COPY requirements.txt /app/
RUN pip install --no-cache-dir -r requirements.txt
COPY . /app
```
Это позволяет использовать кэш слоев и ускоряет сборку.

### Плохая практика 3: Использование root-пользователя
* Почему это плохо?

Запуск контейнера от имени root может привести к уязвимостям безопасности.

Если злоумышленник получит доступ к контейнеру, он сможет выполнять любые команды.

* Как исправлено?

Создается не-root пользователь, и контейнер запускается от его имени:

```
RUN useradd -m myuser && chown -R myuser:myuser /app
USER myuser
```
Это повышает безопасность контейнера.

### Плохой докерфайл кушает много памяти
Если ввести команду
```
docker images
```
то можно увидеть все образы докеров, которые создавались, как мы видим - плохой докер занял в более чем в 4 раза больше памяти

![Снимок экрана от 2025-02-26 21-17-05](https://github.com/user-attachments/assets/2b0f815a-e14e-4773-bf19-922c70908b33)

### Плохие практики по работе с контейнерами
Даже если у вас есть хороший Dockerfile, вы можете допустить ошибки при работе с контейнерами. Вот две распространенные плохие практики:

### Хранение данных внутри контейнера
* Почему это плохо?

Данные, хранящиеся внутри контейнера, теряются при удалении контейнера.

Контейнеры предназначены для временного использования, и их файловая система не предназначена для постоянного хранения данных.

* Как исправить?

Используйте `Docker volumes` или `bind mounts` для хранения данных вне контейнера.

Пример использования volumes:
```
docker run -v /host/path:/container/path myimage
```
Это позволяет сохранять данные даже после удаления контейнера.
### Использование контейнеров как виртуальных машин
* Почему это плохо?

Контейнеры предназначены для запуска одного процесса, а не множества сервисов.

Попытка использовать контейнер как виртуальную машину (например, запуск SSH-сервера внутри контейнера) нарушает принципы контейнеризации.

* Как исправить?

Используйте один контейнер для одного процесса.

Для управления несколькими сервисами используйте Docker Compose или оркестраторы, такие как Kubernetes.

Пример Docker Compose:
```
version: '3'
services:
  web:
    image: nginx
    ports:
      - "80:80"
  db:
    image: postgres
    environment:
      POSTGRES_PASSWORD: example
```
### Итог
* Избегайте хранения данных внутри контейнеров — используйте `volumes`.

* Не пытайтесь использовать контейнеры как виртуальные машины — следуйте принципу "один контейнер — один процесс".



